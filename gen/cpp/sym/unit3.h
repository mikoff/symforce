// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     geo_package/CLASS.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <ostream>
#include <random>
#include <vector>

#include <Eigen/Core>

#include <sym/ops/group_ops.h>
#include <sym/ops/lie_group_ops.h>
#include <sym/ops/storage_ops.h>
#include <sym/rot3.h>
#include <sym/util/epsilon.h>

namespace sym {

/**
 * Autogenerated C++ implementation of `symforce.geo.unit3.Unit3`.
 *
 * Direction in R^3 represented as a unit vector on the S^2 sphere manifold.
 *
 * Storage is three dimensional, and tangent space is two dimensional. Due to the nature of the
 * manifold, the unit X vector is handled as a singularity.
 *
 * The implementation of the retract and local_coordinates functions are based on Appendix B.2 :
 *
 * [Hertzberg 2013] Integrating Generic Sensor Fusion Algorithms with Sound State Representations
 * through Encapsulation of Manifolds
 *
 * The retract operation performs a perturbation to the desired unit X vector, which is then rotated
 * to desired position along the actual stored unit vector through a Householder-reflection +
 * relection across the XZ plane.
 *
 *     x.retract(delta) = x [+] delta = Rx * Exp(delta), where
 *     Exp(delta) = [cos(||delta||), sinc(||delta||) * delta], and
 *     Rx = (I - 2 vv^T / (v^Tv))X, v = x - e_x != 0, X is a matrix negating 2nd vector component
 *        = diag(1, -1, -1)       , x = e_x
 *
 * See: `unit3_visualization.ipynb` for a visualization of the Unit3 manifold.
 */
template <typename ScalarType>
class Unit3 {
 public:
  // Typedefs
  using Scalar = ScalarType;
  using Self = Unit3<Scalar>;
  using DataVec = Eigen::Matrix<Scalar, 3, 1, Eigen::DontAlign>;
  using TangentVec = Eigen::Matrix<Scalar, 2, 1>;
  using SelfJacobian = Eigen::Matrix<Scalar, 2, 2>;

  /**
   * Construct from data vec
   *
   * @param normalize Project to the manifold on construction.  This ensures numerical stability as
   *     this constructor is called after each codegen operation.  Constructing from a normalized
   *     vector may be faster, e.g. with `FromStorage`.
   */
  explicit Unit3(const DataVec& data, const bool normalize = true)
      : data_(normalize ? DataVec(data.normalized()) : data) {}

  // Access underlying storage as const
  inline const DataVec& Data() const {
    return data_;
  }

  // Matrix type aliases
  using Vector3 = Eigen::Matrix<Scalar, 3, 1>;

  // --------------------------------------------------------------------------
  // Handwritten methods included from "custom_methods/unit3.h.jinja"
  // --------------------------------------------------------------------------

  // Generate a random element in Unit3
  template <typename Generator>
  static Unit3 Random(Generator& gen, Scalar epsilon = kDefaultEpsilon<Scalar>) {
    std::uniform_real_distribution<Scalar> dist(0.0, 1.0);
    const auto u1 = dist(gen);
    const auto u2 = dist(gen);
    return RandomFromUniformSamples(u1, u2, epsilon);
  }

  // --------------------------------------------------------------------------
  // Custom generated methods
  // --------------------------------------------------------------------------

  /**
   * Return a :class:`Unit3` that points along the direction of vector ``a``
   *
   * ``a`` will be normalized.
   */
  const static sym::Unit3<Scalar> FromVector(const Vector3& a, const Scalar epsilon);

  /**
   * Returns a :class:`Matrix32` with the basis vectors of the tangent space (in R^3) at the
   * current Unit3 direction.
   */
  const Eigen::Matrix<Scalar, 3, 2> Basis(const Scalar epsilon) const;

  /**
   * Return a :class:`Unit3` that points along the direction of vector ``a``
   *
   * ``a`` is expected to be a unit vector.
   */
  const static sym::Unit3<Scalar> FromUnitVector(const Vector3& a);

  /**
   * Returns a :class:`Vector3` version of the unit direction.
   */
  const Vector3 ToUnitVector() const;

  /**
   * Generate a random :class:`Unit3` direction from two variables uniformly sampled in [0, 1].
   */
  const static sym::Unit3<Scalar> RandomFromUniformSamples(const Scalar u1, const Scalar u2,
                                                           const Scalar epsilon);

  // --------------------------------------------------------------------------
  // StorageOps concept
  // --------------------------------------------------------------------------

  static constexpr int32_t StorageDim() {
    return StorageOps<Self>::StorageDim();
  }

  void ToStorage(Scalar* const vec) const {
    return StorageOps<Self>::ToStorage(*this, vec);
  }

  static Unit3 FromStorage(const Scalar* const vec) {
    return StorageOps<Self>::FromStorage(vec);
  }

  // --------------------------------------------------------------------------
  // LieGroupOps concept
  // --------------------------------------------------------------------------

  static constexpr int32_t TangentDim() {
    return LieGroupOps<Self>::TangentDim();
  }

  Self Retract(const TangentVec& vec, const Scalar epsilon = kDefaultEpsilon<Scalar>) const {
    return LieGroupOps<Self>::Retract(*this, vec, epsilon);
  }

  TangentVec LocalCoordinates(const Self& b, const Scalar epsilon = kDefaultEpsilon<Scalar>) const {
    return LieGroupOps<Self>::LocalCoordinates(*this, b, epsilon);
  }

  Self Interpolate(const Self b, const Scalar alpha,
                   const Scalar epsilon = kDefaultEpsilon<Scalar>) const {
    return LieGroupOps<Self>::Interpolate(*this, b, alpha, epsilon);
  }

  // --------------------------------------------------------------------------
  // General Helpers
  // --------------------------------------------------------------------------

  bool IsApprox(const Self& b, const Scalar tol) const {
    // isApprox is multiplicative so we check the norm for the exact zero case
    // https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c
    if (b.Data() == DataVec::Zero()) {
      return Data().norm() < tol;
    }

    return Data().isApprox(b.Data(), tol);
  }

  template <typename ToScalar>
  Unit3<ToScalar> Cast() const {
    return Unit3<ToScalar>(Data().template cast<ToScalar>());
  }

  bool operator==(const Unit3& rhs) const {
    return data_ == rhs.Data();
  }

  bool operator!=(const Unit3& rhs) const {
    return !(*this == rhs);
  }

 protected:
  DataVec data_;
};

// Shorthand for scalar types
using Unit3d = Unit3<double>;
using Unit3f = Unit3<float>;

// Print definitions
std::ostream& operator<<(std::ostream& os, const Unit3<double>& a);
std::ostream& operator<<(std::ostream& os, const Unit3<float>& a);

}  // namespace sym

// Externs to reduce duplicate instantiation
extern template class sym::Unit3<double>;
extern template class sym::Unit3<float>;

static_assert(sizeof(sym::Unit3<double>) == 3 * sizeof(double));
static_assert(alignof(sym::Unit3<double>) == sizeof(double));
static_assert(sizeof(sym::Unit3<float>) == 3 * sizeof(float));
static_assert(alignof(sym::Unit3<float>) == sizeof(float));

// Concept implementations for this class
#include "./ops/unit3/group_ops.h"
#include "./ops/unit3/lie_group_ops.h"
#include "./ops/unit3/storage_ops.h"
